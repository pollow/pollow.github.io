<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>pollow's blog</title><link href="http://pollow.github.io/" rel="alternate"></link><link href="http://pollow.github.io/feeds/all.atom.xml" rel="self"></link><id>http://pollow.github.io/</id><updated>2016-03-05T22:20:30+08:00</updated><entry><title>Java Language Notes</title><link href="http://pollow.github.io/java-language-notes.html" rel="alternate"></link><updated>2016-03-05T22:20:30+08:00</updated><author><name>XING Chang</name></author><id>tag:pollow.github.io,2016-03-05:java-language-notes.html</id><summary type="html">&lt;p&gt;Date:2016-03-05&lt;/p&gt;
&lt;p&gt;虽然没有长期使用Java的打算，但是本着深入学习语言和设计的想法，还是决定多了解一些Java的高级用法。这几天计划着阅读 GSON 的代码，遇到了一些之前很少遇到的定义问题，简单记录和翻译一下官方文档，以便后人。&lt;/p&gt;
&lt;h2&gt;Inner Class&lt;/h2&gt;
&lt;p&gt;Java 允许在一个 Class 的内部声明另外一个一个 Class，这个特性被称为 nested class，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;OuterClass&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;NestedClass&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nested Class 有 static 和 non-static 的区别，static 的声明如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;OuterClass&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StaticNestedClass&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;InnerClass&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;被声明为 static 的内部类被叫做 static nested classes, 而 non-static 的就被叫做 inner class。&lt;/p&gt;
&lt;p&gt;所有的 Nested Class 都是外部类的成员，都可以访问到 enclosing class 的成员变量和方法。&lt;/p&gt;
&lt;p&gt;Nested Class 的可见性可以是 private, public, protected 或者 package private，含义明显，不赘述。&lt;/p&gt;
&lt;p&gt;在编译成.class文件的时候，所有的内部类都会被编译成单独的.class文件，末尾附带有$\d+的标志。&lt;/p&gt;
&lt;h3&gt;Static Nested Class&lt;/h3&gt;
&lt;p&gt;Static Nested Class 的特殊在于只能够访问 enclosing class 的静态方法和静态变量，同时可以被静态的使用(实例化)，并且可以拥有非静态的成员变量和方法。&lt;/p&gt;
&lt;h3&gt;Inner Class&lt;/h3&gt;
&lt;p&gt;Inner Class 总是伴随着一个实例化的 Enclosing Class，并且可以直接访问所有的成员和方法，并且由于它总是伴随着 Enclosing Class，所以不能够定义 static 成员在其中。因为 Inner Class 有 Enclosing Class 的引用，所以想要实例化一个 Inner Class, 必须首先实例化 Enclosing Class, 如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;OuterClass&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;InnerClass&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;OuterClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;InnerClass&lt;/span&gt; &lt;span class="n"&gt;innerObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;outerObject&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;new&lt;/span&gt; &lt;span class="nf"&gt;InnerClass&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我之所以对 Inner Class 产生疑问，就是因为在阅读 GSON 的 &lt;a href="https://github.com/google/gson/blob/master/UserGuide.md#TOC-Overview"&gt;User Guide &lt;/a&gt; 的时候看到，不支持直接实例化一个 Inner Class，从而感觉自己对 Inner Class 的语法和规范有所困惑。&lt;/p&gt;
&lt;h3&gt;Local Class&lt;/h3&gt;
&lt;p&gt;Local Class 是定义在 Block 中的 Class, 在写UI(或者是频繁实例化 interface)的时候经常用到，值得注意的是 Local Class 只能访问 enclosing local scope 中的变量(Java 8 之前要求标志为final, Java 8 之后允许effectively final)。&lt;/p&gt;
&lt;p&gt;Local Class 可以访问 Enclosing Class 的所有成员，但是注意，定义在 static 函数中的 Local Class 只能够访问 static 变量。Local Class 是 non-static Inner Class，因为他们都拥有对于 Enclosing Block 的访问权，所以 Local Class 和 Inner Class 类似，都不能够定义 static 成员。因此，也不能够在 Block 中定义 interface，因为 interface 本身是静态的。不过例外是，可以定义CONSTANT。&lt;/p&gt;
&lt;h3&gt;Anonymous Class&lt;/h3&gt;
&lt;p&gt;匿名类和 Local Class 完全一致，除了没有名字。支持匿名类完全是为了代码的简洁性。借助匿名类可以在声明 Local  Class 的同时直接实例化。实际使用中，&lt;strong&gt;主要用作实现 interface&lt;/strong&gt;。&lt;/p&gt;</summary></entry><entry><title>Spring MVC 入门笔记</title><link href="http://pollow.github.io/spring-mvc-ru-men-bi-ji.html" rel="alternate"></link><updated>2016-02-13T00:00:00+08:00</updated><author><name>XING Chang</name></author><id>tag:pollow.github.io,2016-02-13:spring-mvc-ru-men-bi-ji.html</id><summary type="html">&lt;p&gt;看了一遍入门手册，大概有点影响，但是版本略微有些老，所以为了流畅使用，又基本撸了一遍reference，中间还被莫名其妙的Spring Boot迷惑了半天，总算基本搞懂运行流程。&lt;/p&gt;
&lt;h2&gt;基础知识&lt;/h2&gt;
&lt;h2&gt;实际功能分析&lt;/h2&gt;
&lt;h3&gt;Interceptor&lt;/h3&gt;
&lt;p&gt;Interceptor的功能类似Servlet中的Filter。&lt;/p&gt;</summary></entry><entry><title>Gradle in Action 阅读笔记</title><link href="http://pollow.github.io/gradle-in-action-yue-du-bi-ji.html" rel="alternate"></link><updated>2016-02-09T00:00:00+08:00</updated><author><name>XING Chang</name></author><id>tag:pollow.github.io,2016-02-09:gradle-in-action-yue-du-bi-ji.html</id><summary type="html">&lt;p&gt;最近发现各种技术书籍真是啰里啰嗦絮絮叨叨，就不能平铺直叙说清楚事情么……&lt;/p&gt;
&lt;h2&gt;简洁&lt;/h2&gt;
&lt;p&gt;Gradle的优点在于其保留了Ant、Maven的可扩展性，一定程度的向上兼容，方便历史项目缓慢的向Gradle迁移的同时，还提供更加简洁语法和底层的api，并且使用了Ivy和Maven的包仓库。&lt;strong&gt;这种借用流行的当前项目资源，提供向上兼容的同时提供更加优良的特性的开源项目开发方法，值得借鉴&lt;/strong&gt;。和Maven一样，Gradle不是简单的Make程序或者npm的包管理器，而是一整套的构建工具(building tools)，当然，对于个人小项目，使用它的主要目的也仅仅是make好依赖管理以及自动测试，对于团队来说，更好的分离了测试环境和产品部署，简化了持续交付。&lt;/p&gt;
&lt;h2&gt;入门&lt;/h2&gt;
&lt;h3&gt;构建&lt;/h3&gt;
&lt;p&gt;Java项目的构建和部署本身十分繁杂，而且大多数情况下都仅仅使用默认配置(convention)。Gradle将这些convention总结起来，利用其插件机制作为了一个Java项目插件，只要在构建脚本（默认为&lt;code&gt;build.gradle&lt;/code&gt;，也可以在命令行中通过参数指定脚本）中使用此插件，即可包含所有的默认配置。所以，写一个简单的项目，并且在根目录新建包含如下内容的&lt;code&gt;build.gradle&lt;/code&gt;脚本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;apply plugin: &amp;#39;java&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在命令行中使用&lt;code&gt;gradle build&lt;/code&gt;命令即可完成构建。&lt;/p&gt;
&lt;p&gt;显然，默认配置不能满足每个人自己的项目需求，我们需要自定义。只要在脚本后面加上属性值，即可覆盖默认设置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;apply plugin: &amp;#39;java&amp;#39;
version = 0.1
sourceCompatibility = 1.8

jar {
    manifest {
        attributes &amp;#39;Main-Class&amp;#39;: &amp;#39;me.aubee.todo.ToDoApp&amp;#39;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个脚本设置了当前应用的版本号（体现在jar包上），兼容的JRE环境，以及Manifest文件的启动路径（要打包成可执行的jar包(standalone)，还可以使用&lt;code&gt;application plugin&lt;/code&gt;，参见&lt;a href="https://docs.gradle.org/current/userguide/application_plugin.html"&gt;这个链接&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;所有可用的属性（properties）可以通过命令行&lt;code&gt;gradle properties&lt;/code&gt;查看。&lt;/p&gt;
&lt;h3&gt;依赖&lt;/h3&gt;
&lt;p&gt;由于之前最流行的依赖管理工具是Maven，所有Gradle支持使用Maven的软件仓库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;repositories {
    mavenCentral()
}

dependencies {
    compile group: &amp;#39;org.apache.commons&amp;#39;, name: &amp;#39;commons-lang3&amp;#39;, version: &amp;#39;3.1&amp;#39;
}   
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;group, name, version 分别对应了Maven的groupId, artifactId和version。如上的依赖也可以写成简写&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;dependencies {
    compile &amp;#39;org.apache.commons:commons-lang3:3.1&amp;#39;
}   
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，build的时候就会自动从Maven仓库中下载对应的jar包。&lt;/p&gt;
&lt;h3&gt;Web Application&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;war plugin&lt;/code&gt;，默认需要将web resource放置到&lt;code&gt;src/main/webapp&lt;/code&gt;中，构建中会多出war环节。所有的webapp目录下的文件会被拷贝到WAR file的根下，编译的classes文件放置在&lt;code&gt;WEB-INF/classes&lt;/code&gt;下，所有的依赖放置在&lt;code&gt;WEB-INF/lib&lt;/code&gt;中，成为一个符合Java EE标准的war file，link到tomcat中即可使用。&lt;/p&gt;
&lt;p&gt;还可以使用&lt;code&gt;jetty plugin&lt;/code&gt;，利用Gradle内嵌的一个jetty服务器运行webapp，但是由于过于legacy，暂时不作考虑。在构建的时候加一个soft link到tomcat的目录即可。&lt;/p&gt;
&lt;h3&gt;Gradle Wrapper&lt;/h3&gt;
&lt;p&gt;这是一个用来消除多人合作时，由于跨平台和不同版本Gradle引起的不兼容型问题的脚本工具。使用很简单，暂时也不需要，不多讨论。&lt;/p&gt;
&lt;h2&gt;基础&lt;/h2&gt;</summary></entry><entry><title>Hibernate 入门笔记</title><link href="http://pollow.github.io/hibernate-ru-men-bi-ji.html" rel="alternate"></link><updated>2016-02-05T00:00:00+08:00</updated><author><name>XING Chang</name></author><id>tag:pollow.github.io,2016-02-05:hibernate-ru-men-bi-ji.html</id><summary type="html">&lt;p&gt;Java 项目库看多了，尤其是Apache的，换上了严重的文档阅读恐惧症，严重倾向于阅读经过加工后的中文教材，然后去看reference。Getting Start真没什么好东西。&lt;/p&gt;
&lt;h2&gt;基础&lt;/h2&gt;
&lt;p&gt;Hibernate 是一个 ORM 框架，全称 Object-Relative Database-Mapping，显而易见，是一个在Java对象和关系型数据库之间建立连接的&lt;strong&gt;中间件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Hibernate在2005年被JBoss收购，JBoss之后被Red Hat收购，所以现在算起来HIbernate是Red Hat旗下的开源库了。&lt;/p&gt;
&lt;p&gt;早起Hibernate使用XML配置POJO（我现在的工程中使用的方法），现在的Hibernate支持JPA（Java Persistence API），也可以使用注解的方法配置（今天在浏览 Spring 框架的时候，看到也有一个 Spring Data，之后也可稍作研究）。&lt;/p&gt;
&lt;h2&gt;使用笔记&lt;/h2&gt;
&lt;p&gt;创建一个类，推荐为POJO，使用&lt;code&gt;@Entity&lt;/code&gt;注解，使之为一个实体类，既与数据库有映射关系。实体类还需要在类声明处用&lt;code&gt;@Table&lt;/code&gt;注解表明，属性处用&lt;code&gt;@id&lt;/code&gt;定义主键，&lt;code&gt;@Column&lt;/code&gt;定义列；还有其他的一些外键和类型注解。&lt;/p&gt;
&lt;p&gt;Hibernate 通常还需要一个工具类，官方提供了HibernateUtil，用于方便创建Session，Transaction等。&lt;code&gt;SessionFactory&lt;/code&gt;是一个线程安全的 Session 工厂类；得到Session后，每次执行请求，都需要打开Session，打开Transaction，执行请求，关闭Transaction，关闭Session。这种重复工作显然不合理。&lt;/p&gt;
&lt;p&gt;在Web中使用 Hibernate，配置文件要设置&lt;code&gt;current_session_context_class&lt;/code&gt;为thread (for tomcat,不知为何)。&lt;/p&gt;
&lt;p&gt;推荐为 Hibernate 设置乐观锁，在POJO中增加一列&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nd"&gt;@Version&lt;/span&gt;
&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;问题是，会在数据库表中增加一列Version么？难道数据库的全部配置都要交给Hibernate，由Hibernate自动创建数据库么？一般来说，不都是DBA完成数据库的创建、调优，然后中间层只是方便CURD么？那么Hibernate如何利用View呢？&lt;/p&gt;
&lt;h2&gt;Entity Class&lt;/h2&gt;
&lt;p&gt;当一个类被&lt;code&gt;@Entity&lt;/code&gt;注解标记的时候，说明这个类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用了标准的 JavaBean 约定。&lt;/li&gt;
&lt;li&gt;必须包含无参构造函数，Hibernate会使用无参构造函数，利用Java反射创造实体。&lt;/li&gt;
&lt;li&gt;Entity的属性默认为数据库的列，即使没有任何注解标明。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;外联关系&lt;/h2&gt;
&lt;p&gt;Hibernate会自动处理复杂的外链关系，在声明POJO的时候需要配合注解使用。在配置文件中可以设置，取数据时是否连带外键一同获取，并且设置深度。cascade属性可以配置是否保存对象的同时保存外键。&lt;/p&gt;
&lt;p&gt;查询外键的时候有延时加载和即时加载两种模式，推荐使用延迟加载（默认选项），获取更好的性能，但是也要考虑可能的异常（数据库连接断掉）。&lt;/p&gt;
&lt;h2&gt;HQL&lt;/h2&gt;
&lt;p&gt;HQL相对于SQL，只是针对面向对象的设计做了小修改。需要有如下注意点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在设计类名、包名时，大小写敏感&lt;/li&gt;
&lt;li&gt;可以使用&lt;code&gt;select class&lt;/code&gt;的方法获取对象，这种情况下也可以省略select语句。&lt;/li&gt;
&lt;li&gt;如果查询的不是整个对象，而是一些字段，可以选择返回&lt;code&gt;Object[]&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;，语法细节查询文档。&lt;/li&gt;
&lt;li&gt;where字句允许通过.(dot)进行简单的外键访问，允许对集合类型调用size函数。&lt;/li&gt;
&lt;li&gt;推荐使用名称占位符&lt;code&gt;:name&lt;/code&gt;写入数据，调用&lt;code&gt;setParamter&lt;/code&gt;系列函数传入数据（不知道是否会转义）。&lt;/li&gt;
&lt;li&gt;分页可以调用Query对象的&lt;code&gt;setFirstResult&lt;/code&gt;和&lt;code&gt;setMaxResults&lt;/code&gt;函数。&lt;/li&gt;
&lt;li&gt;也支持各种join查询。&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;SQLQuery&lt;/code&gt;可以使用SQL进行查询，通过设置&lt;code&gt;addEntity&lt;/code&gt;可以配置返回实体。&lt;/li&gt;
&lt;li&gt;常用的简单查询可以使用&lt;code&gt;@NamedQuery&lt;/code&gt;配置。  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;JPA&lt;/h2&gt;
&lt;p&gt;JPA 是 Java 指定的一组关于持久化的接口，Hibernate提供了相关的服务。相比于标准的 Hibernate 配置，JPA有自己的启动配置文件，名为&lt;code&gt;persistence.xml&lt;/code&gt;。和&lt;code&gt;hibernate.cfg.xml&lt;/code&gt;有所不同，但也十分接近。&lt;/p&gt;
&lt;p&gt;具体的配置可以参考&lt;a href="http://docs.jboss.org/hibernate/orm/5.1/userguide/html_single/Hibernate_User_Guide.html#bootstrap-jpa"&gt;这个链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;虽然相对于 Native Hibernate API 损失了一些灵活性，并且无法利用更加OO的HQL，但是还是更加推荐使用JPA。官方统一的标准意味着后期更换 JPA Provider 会比较容易（虽然我认为没有必要）。&lt;/p&gt;
&lt;h2&gt;Spring DAO模块&lt;/h2&gt;
&lt;p&gt;如上所述，进行查询的时候通常需要一系列打开，关闭的琐碎操作，DAO层封装了这些操作。&lt;/p&gt;
&lt;h2&gt;Spring Service模块&lt;/h2&gt;
&lt;h2&gt;Spring Data&lt;/h2&gt;
&lt;h2&gt;jOOQ&lt;/h2&gt;
&lt;h2&gt;torpedoquery&lt;/h2&gt;
&lt;h2&gt;Questions&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;@GeneratedValue&lt;/code&gt;是否会和数据库默认的auto increment 冲突？&lt;/p&gt;</summary></entry><entry><title>ZML Reading Note</title><link href="http://pollow.github.io/zml-reading-note.html" rel="alternate"></link><updated>2016-02-03T00:00:00+08:00</updated><author><name>XING Chang</name></author><id>tag:pollow.github.io,2016-02-03:zml-reading-note.html</id><summary type="html"></summary></entry><entry><title>Android 学习日记 Activity</title><link href="http://pollow.github.io/android-xue-xi-ri-ji-activity.html" rel="alternate"></link><updated>2016-02-02T00:00:00+08:00</updated><author><name>XING Chang</name></author><id>tag:pollow.github.io,2016-02-02:android-xue-xi-ri-ji-activity.html</id><summary type="html">&lt;p&gt;文中出现的『书中』字样，均指代『《第一行代码》2014年第一版』。&lt;/p&gt;
&lt;p&gt;我最终使用的是 Android 5.0 SDK 23，运行的虚拟机却是 Android 6.0；暂时未出现明显兼容性问题。&lt;/p&gt;
&lt;h2&gt;Activity&lt;/h2&gt;
&lt;p&gt;一个 Activity（活动） 是 Android SDK 中 Activity 类的子类，负责呈现视图和数据，与用户进行交互。每一个活动需要一个对应的布局（layout）负责描述界面对象信息。&lt;/p&gt;
&lt;p&gt;创建一个活动首先需要在包中创建一个新类，继承 Activity 类，重载&lt;code&gt;onCreate&lt;/code&gt;函数，并在&lt;code&gt;onCreate&lt;/code&gt;函数中调用&lt;code&gt;setContentView&lt;/code&gt;来为活动家在布局。索引布局可以使用&lt;code&gt;R.layout.layout_id&lt;/code&gt;；R文件在gen文件夹中，是自动生成的一个包含了所有资源id的java文件。&lt;/p&gt;
&lt;p&gt;所有的活动都需要在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;中注册；在manifest标签中制定了package的话，可以省略Activity标签中class的包名。&lt;/p&gt;
&lt;p&gt;在&lt;activity&gt;标签中指定的label作为标题栏内容（如何去除标题栏还有一些疑问），如果是主活动的话，这个也会作为应用名称出现在 Launcher(drawer) 中。如果没有在&lt;activity&gt;标签中指定label的话并且需要label的话，则会使用上一级的&lt;application&gt;的label属性。&lt;/p&gt;
&lt;p&gt;一个&lt;activity&gt;标签中通常定义一些&lt;intent-filter&gt;标签，里面包含对于intent的定义（action &amp;amp; category），这个用于指定启动条件，后文再详述。一个&lt;strong&gt;主活动&lt;/strong&gt;就是包含了如下&lt;intent-filter&gt;的活动：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;intent-filter&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;action&lt;/span&gt; &lt;span class="na"&gt;android:name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;android.intent.action.MAIN&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;category&lt;/span&gt; &lt;span class="na"&gt;android:name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;android.intent.category.LAUNCHER&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/intent-filter&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个活动就是打开应用的第一个活动，如果没有指定主活动，则无法在 Launcher 中看到应用，&lt;strong&gt;如果指定多个活动&lt;/strong&gt;，则在Launcher中会出现多个对应的程序图标，分别指向各自的活动。&lt;/p&gt;
&lt;h3&gt;隐藏标题栏&lt;/h3&gt;
&lt;p&gt;书中『隐藏标题栏』一章中的方法在 Android 5.0 SDK 中已经不可用。&lt;/p&gt;
&lt;h3&gt;Toast&lt;/h3&gt;
&lt;p&gt;Toast 就是在屏幕下方出现的半透明提醒框，一定时间后消失，没有其余的交互信息。推荐通过 Toast 将一些短小的消息通知给用户。&lt;/p&gt;
&lt;p&gt;使用时，通过调用 Toast 的静态方法&lt;code&gt;makeText&lt;/code&gt;创建一个 Toast 对象，调用这个对象的&lt;code&gt;show&lt;/code&gt;方法展示。&lt;code&gt;makeText&lt;/code&gt;需要三个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Context&lt;/li&gt;
&lt;li&gt;文本内容（String）&lt;/li&gt;
&lt;li&gt;时长，通过两个常亮设定：&lt;code&gt;Toast.LENGTH_SHORT&lt;/code&gt; &amp;amp; &lt;code&gt;Toast.LENGTH_LONG&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Menu&lt;/h3&gt;
&lt;p&gt;&lt;del&gt;书中的创建 Menu 方法已不可用；我创建的虚拟机基于 Nexus 4，已经没有了实体按键，Android 6.0 的虚拟按键中也没有菜单键。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;在Android 3.0后，Android设备不再要求提供实体Menu按钮，并且越来越多的现代设备已经不提供，比如我实验用的N4。在新的系统中，菜单被放置在了 app bar 的右侧。书中的实验前置步骤中去掉了标题栏，所以无法激活Menu，将app bar显示出来即可。&lt;/p&gt;
&lt;p&gt;MenuItem支持嵌套，在item中可以继续增加menu。新的标准也支持在XML中指定onClick回调，而不是重载。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;onCreateOptionsMenu&lt;/code&gt;应该仅仅新建一个初始的Menu，这个函数只会被调用一次，Menu保持不变。在3.0之后的系统中，如果希望基于用户的操作、活动属性、数据变化等动态的调整Menu的，可以动态的调用&lt;code&gt;invalidateOptionsMenu()&lt;/code&gt;函数，系统会调用&lt;code&gt;onPrepareOptionsMenu(Menu)&lt;/code&gt;，在其中可以动态的修改菜单条目。&lt;/p&gt;
&lt;p&gt;此外，还有一个可以绑定到(anchored to)的popup menu，比如一个button之类。&lt;/p&gt;
&lt;p&gt;进一步内容可以查阅官方指南 &lt;a href="http://developer.android.com/guide/topics/ui/menus.html"&gt;Menu&lt;/a&gt; 和 &lt;a href="http://developer.android.com/guide/topics/resources/menu-resource.html"&gt;Menu Resource&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;销毁活动&lt;/h3&gt;
&lt;p&gt;按下 Back 键即可销毁活动并且返回上一个活动；在函数中调用&lt;code&gt;finish&lt;/code&gt;方法也可以销毁活动。&lt;code&gt;finish&lt;/code&gt;方法定义在&lt;code&gt;Activity&lt;/code&gt;类中。&lt;/p&gt;
&lt;h2&gt;Intent&lt;/h2&gt;
&lt;p&gt;当应用拥有多个活动时（通常情况），可以使用 Intent 进行切换，同时传递数据。&lt;/p&gt;
&lt;p&gt;Intent 是 Android 程序中在各个组件之间切换的重要方式，本节最后将简要归纳所有的 Intent 用法，不局限在 Activity 组件当中。&lt;/p&gt;
&lt;h3&gt;显式调用&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Intent&lt;/span&gt; &lt;span class="n"&gt;intent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Intent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FirstActivity&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;this&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SecondActivity&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;startActivityForResult&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;intent&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;直接调用 Intent 的构造函数，传入 Context 和目标 Activity 的 Class（内部使用了RTTI么？）；之后调用&lt;code&gt;startActivity&lt;/code&gt;启动新的活动；之所以将这种调用方式称为&lt;strong&gt;显式调用&lt;/strong&gt;，是因为在构造函数中显式制定了目标活动，相对应的，隐式调用就没有指明目标活动。&lt;/p&gt;
&lt;h3&gt;隐式调用&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Intent&lt;/span&gt; &lt;span class="n"&gt;intent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Intent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;me.aubee.activitytest.ACTION_START&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;startActivity&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;intent&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在调用 Intent 的构造函数的时候传入一个"action name"，再调用&lt;code&gt;startActivity&lt;/code&gt;即可。如果没有指定category的话，默认使用&lt;code&gt;android.intent.category.DEFAULT&lt;/code&gt;。这时会启动同时匹配action name和category name的Activity（在&lt;intent-filter&gt;标签中设置）。&lt;/p&gt;
&lt;p&gt;如果有多个活动被匹配到，则会弹出选择框，选择启动哪个活动。同时，这也是和其他应用协同工作的机制，通过设置指定的action name，可以启动其他同时绑定了这个action name的应用程序。这里有两个额外的概念：Uri和Scheme。&lt;/p&gt;
&lt;p&gt;Uri就是一个资源修饰符（Universal resource identifier），其中的协议部分即是scheme，比如http等。在&lt;indent-filter&gt;标签中可以使用&lt;data&gt;标签指定支持的scheme等五个属性。只有&lt;data&gt;标签指定的内容和Intent携带的Data完全一致的时候，才会启动活动。这里不一定要使用Uri，书上给的例子不太全面，具有一定的误导性，我在经过查询后得到以下的说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Intent.ACTION_VIEW&lt;/code&gt;是一个通用的做法，跨程序启动，或者说公用的接口都应该设置这个action_name&lt;/li&gt;
&lt;li&gt;匹配的是Data，可以通过任何方法生成Uri，比如&lt;code&gt;Uri.fromFile&lt;/code&gt;可以获取文件的修饰符，我在下面给出一个来自StackOverflow的而关于启动pdf文件的例子。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Environment&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getExternalStorageDirectory&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getAbsolutePath&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Intent&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Intent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Intent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ACTION_VIEW&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setDataAndType&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Uri&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fromFile&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;application/pdf&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setFlags&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Intent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;FLAG_ACTIVITY_NO_HISTORY&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;Intent&lt;/span&gt; &lt;span class="n"&gt;intent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Intent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createChooser&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Open File&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;startActivity&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;intent&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ActivityNotFoundException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Instruct the user to install a PDF reader here, or something&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;传递数据&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;putExtra(String key, Object value)&lt;/code&gt;可以传递数据给下一个活动&lt;/li&gt;
&lt;li&gt;在下一个活动中使用&lt;code&gt;getIntent&lt;/code&gt;获取Intent，&lt;code&gt;getExtra&lt;/code&gt;获取数据&lt;/li&gt;
&lt;li&gt;首先在上一个活动需要调用&lt;code&gt;startActivityForResult&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;返回数据&lt;strong&gt;同样需要借助Intent&lt;/strong&gt;，启动的活动需要&lt;strong&gt;用无参构造函数&lt;/strong&gt;实例化一个Intent，设置数据后调用&lt;code&gt;setResult&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;上一个活动同时要重载&lt;code&gt;onActivityResult()&lt;/code&gt;方法，这个方法会在目标活动结束后被毁掉&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;保存数据&lt;/h2&gt;
&lt;p&gt;活动在后台的时候可能随时被回收，但是回收前一定会调用&lt;code&gt;onSaveInstanceState()&lt;/code&gt;方法，用来保存数据。保存的数据存在一个Bundel对象中，在onCreate被调用时作为参数传回。&lt;/p&gt;
&lt;h2&gt;生命周期和启动模式&lt;/h2&gt;
&lt;p&gt;这两部分书中讲解十分详细，不赘言。&lt;/p&gt;
&lt;h2&gt;Wait for Update&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在AS中新建Activity默认继承的是&lt;code&gt;AppCompatActivity&lt;/code&gt;，和&lt;code&gt;Activity&lt;/code&gt;有什么区别？&lt;/li&gt;
&lt;li&gt;关于Menu的创建。&lt;/li&gt;
&lt;li&gt;关于标题栏的设置。&lt;/li&gt;
&lt;/ol&gt;</summary><category term="memo"></category><category term="android"></category></entry><entry><title>Java Web 的测试</title><link href="http://pollow.github.io/java-web-de-ce-shi.html" rel="alternate"></link><updated>2016-01-23T00:00:00+08:00</updated><author><name>XING Chang</name></author><id>tag:pollow.github.io,2016-01-23:java-web-de-ce-shi.html</id><summary type="html">&lt;p&gt;前几天研究了 Java Web 中如何利用 log4j 记录 log，方便追踪少见的错误和异常，更加优雅的拜托 stdout 来 debug。这几天主要要钻研一下如何在一个 Java Web 的大型系统中优雅的做测试，包括单元测试和集成测试。&lt;/p&gt;
&lt;p&gt;由于工程庞大，错综复杂，而且目前一直处于在线调试的状态，缺少各种基础设施，所以加入测试难度颇高，今天简单的搜索了一下，检索到了一些关键技术和工具，暂作记录，空下来后慢慢研究。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JUnit 4 -- StrutsSpringJUnit4TestCase&lt;/li&gt;
&lt;li&gt;&lt;a href="http://watij.com/"&gt;Watji&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;h2 in-memory database&lt;/li&gt;
&lt;li&gt;Mock Class&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;感觉想要成功的为整套系统加入测试，对于很多 Java 的概念和框架还需要深入学习，目前看来，遇到 IoR 和 Bean 相关的概念时还是有些不明所以。&lt;/p&gt;
&lt;p&gt;想要进行单元测试，有几个问题需要解决&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何模拟 Request 请求&lt;/li&gt;
&lt;li&gt;如何判断请求处理是否正常&lt;/li&gt;
&lt;li&gt;如何劫持 Hibernate 的数据库操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于第一三两个问题，StackOverflow 上很多答案都提到了 Mock Class 的概念，似乎是利用了 IoR 区分了开发和部署环境下 Hibernate 的行为。为了更好的理解这些用法，还需要对 Spring Core 进行深入的研究。&lt;/p&gt;
&lt;p&gt;说白了 SSH 经典框架我现在就研究了 Struts2，还总被坑奇怪的地方坑。&lt;/p&gt;
&lt;p&gt;Watji 是一个通过模拟浏览器行为，加入断言库来进行测试的框架，优点在于可以测试页面在浏览器中的行为，可能还可以处理 JavaScript 页面的展示问题。问题在于，现在的系统大量使用了 iframe 的嵌套，但是我在 API 中没有看到对于 iframe 如何进行分析。&lt;/p&gt;
&lt;p&gt;其次还需要把整个工程的几个G代码全都拿来梳理/整理一遍，重新设计工程结构，方便本地开发、调试、测试和发布，这么看来，还应该学习一下 Gradle 的用法。&lt;/p&gt;
&lt;p&gt;简单的记录了一下这几天的学习，都是一些技术性上的问题，但是在处理 legacy code 的问题上，还需要学习一些哲学上和概念上的思路。买了本《重构》已经在路上了，任重而道远。&lt;/p&gt;
&lt;p&gt;总之，Java 最擅长创造名词……&lt;/p&gt;</summary><category term="Java"></category><category term="JUnit"></category></entry><entry><title>Log4j 学习与配置</title><link href="http://pollow.github.io/log4j-xue-xi-yu-pei-zhi.html" rel="alternate"></link><updated>2016-01-22T00:00:00+08:00</updated><author><name>XING Chang</name></author><id>tag:pollow.github.io,2016-01-22:log4j-xue-xi-yu-pei-zhi.html</id><summary type="html">&lt;p&gt;开始的时候就被这个项目居然使用 System.out.println 调试大法震惊了一下，由于我也懒得在架构上动手脚，所以也就随大流将就一下。但是最近遇到几个问题，一是我写的一个方法逻辑太过复杂，有太多的数据库操作（其实应该避免，但是因为API不够丰富，逻辑又十分复杂暂时只能如此了）；二是有一些客户报告了一下我在本地无法复现，有很偶然才会发生的 bug，不得已，我决定使用一下 Logger，在相关的函数中记录一下关键值。&lt;/p&gt;
&lt;h2&gt;基础使用&lt;/h2&gt;
&lt;p&gt;记录需要使用 Logger, Logger 应该是单例模型，在应用初始化的时候创建并且保留以后一直使用；不过 LogManager 会处理这些事情，只要提供合适的 Logger 名称，它会在内部管理所有的 Logger。Logger的名字推荐和使用的类名一致，这也是&lt;code&gt;LogManager.getLogger()&lt;/code&gt;的默认行为。&lt;/p&gt;
&lt;p&gt;常用的又 INFO, DEBUG, WARN, ERROR 四个等级，对应四个函数；可以使用 printf 函数默认调用 String Formatter；有 entry, exit 两个函数处理 Flow Tracing。（如果每个函数都要在进入和退出的时候调用这两个函数，是不是可以使用装饰器方法操作？）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;debug&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Logging in user {} with birthday {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBirthdayCalendar&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;API 2.x 中表示可以直接调用函数，不需要检查 log 等级是否开启，不知道 API 1.x 中是否可以这样使用。&lt;/p&gt;
&lt;p&gt;如果是 Java 8，可以借助 Lambda 表达式完成 lazy-evaluation.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;trace&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Some long-running operation returned {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;expensiveOperation&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;高级用法暂时不提。&lt;/p&gt;
&lt;h2&gt;Configuration&lt;/h2&gt;
&lt;p&gt;感觉 log4j 的配置十分复杂，和各种框架也有耦合（主要是框架使用了 log4j 作为日志输出）。&lt;/p&gt;
&lt;p&gt;Log4j 推荐的配置方法是通过配置文件进行配置，如果无法定位到配置文件的话，则会使用默认配置 DefaultConfiguration class. 默认输出到控制台，只显示 ERROR 级别。&lt;/p&gt;
&lt;p&gt;Log4j 支持多种配置格式和文件名，具体可以参考 &lt;a href="http://logging.apache.org/log4j/2.x/manual/configuration.html"&gt;Configuration&lt;/a&gt;。通常来说，在工程的配置目录中添加 &lt;code&gt;log4j2.properties&lt;/code&gt; 文件最为合适。&lt;/p&gt;
&lt;p&gt;一个 XML 设置的结构通常如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;;
&lt;span class="nt"&gt;&amp;lt;Configuration&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;Properties&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;Property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name1&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;value&lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;Property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name2&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;value2&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/Properties&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;filter&lt;/span&gt;  &lt;span class="err"&gt;...&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;Appenders&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appender&lt;/span&gt; &lt;span class="err"&gt;...&lt;/span&gt; &lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;filter&lt;/span&gt;  &lt;span class="err"&gt;...&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appender&amp;gt;&lt;/span&gt;
    ...
  &lt;span class="nt"&gt;&amp;lt;/Appenders&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;Loggers&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;Logger&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name1&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;filter&lt;/span&gt;  &lt;span class="err"&gt;...&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/Logger&amp;gt;&lt;/span&gt;
    ...
    &lt;span class="nt"&gt;&amp;lt;Root&lt;/span&gt; &lt;span class="na"&gt;level=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;level&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;AppenderRef&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/Root&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/Loggers&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/Configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;\&amp;lt;Configuration&gt; 可以包含 status 属性，配置 log4j 内部的 log 级别，遇到问题是可以设置为 trace 来排查。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最关键的是&lt;/strong&gt;要将 log 写入文件中，需要设置 Appender 的类型。我声明 Appender&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;Appender&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;File&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行时会出现 CLASS_NOT_FOUND 的异常。简单查询了一下，和 ClassLoader 有关，暂时没有研究；设置 Appender为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;File&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;File&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;fileName=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;${filename}&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;PatternLayout&lt;/span&gt; &lt;span class="na"&gt;pattern=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/File&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;成功将 log 写入文件中。&lt;/p&gt;
&lt;h2&gt;RollingFile&lt;/h2&gt;
&lt;p&gt;详细而复杂的 Appender 配置可以参考 &lt;a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#RollingFileAppender"&gt;Appenders&lt;/a&gt;。这里简单记录一下如何配置 RollingFile，既设置条件自动归档旧记录的方法。&lt;/p&gt;
&lt;p&gt;配置&lt;code&gt;RollingFileAppender&lt;/code&gt;需要设置&lt;code&gt;TriggeringPolicy&lt;/code&gt;和&lt;code&gt;RolloverStrategy&lt;/code&gt;两个属性，分别用来判断何时归档以及归档名称。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;Policies&lt;/code&gt;标签设置&lt;code&gt;CompositeTriggeringPolicy&lt;/code&gt;属性，内部可以包含多个&lt;code&gt;Policies&lt;/code&gt;，任意一个为真都会产生新文件并归档旧文件。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;DefaultRolloverStrategy&lt;/code&gt;配置命名策略，使用滑动窗口侧策略，有四个参数可以配置：fileIndex, min, max, compressionLevel。fileIndex可以设置为&lt;code&gt;min&lt;/code&gt;或者&lt;code&gt;max&lt;/code&gt;，表示新归档的日志的明明方向（最大 or 最小），max 为窗口大小，超过 max 后会自动删除最老的归档。同时，默认策略在&lt;code&gt;filePattern&lt;/code&gt;中同时接受时间和序号两个参数。一下是官网提供的一个样例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;Configuration&lt;/span&gt; &lt;span class="na"&gt;status=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;warn&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;MyApp&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;packages=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;Appenders&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;RollingFile&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;RollingFile&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;fileName=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;logs/app.log&amp;quot;&lt;/span&gt;
                 &lt;span class="na"&gt;filePattern=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;logs/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;PatternLayout&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;Pattern&amp;gt;&lt;/span&gt;%d %p %c{1.} [%t] %m%n&lt;span class="nt"&gt;&amp;lt;/Pattern&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/PatternLayout&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;Policies&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;TimeBasedTriggeringPolicy&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;SizeBasedTriggeringPolicy&lt;/span&gt; &lt;span class="na"&gt;size=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;250 MB&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/Policies&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/RollingFile&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/Appenders&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;Loggers&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;Root&lt;/span&gt; &lt;span class="na"&gt;level=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;error&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;AppenderRef&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;RollingFile&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/Root&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/Loggers&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/Configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出&lt;code&gt;%i&lt;/code&gt;和&lt;code&gt;%d&lt;/code&gt;分别代表了序号和时间，时间格式和Java常用的配置相同。这个配置默认会产生最多七个归档，但是代码中并没有7这个数字出现，猜测为默认配置。同时还会调用&lt;code&gt;gzip&lt;/code&gt;压缩，猜测是通过文件后缀名判断的压缩算法……&lt;/p&gt;
&lt;p&gt;以上介绍了简单的 RollingFile 配制方法，已经足够简单实用，更加复杂的需求请参考&lt;a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#RollingFileAppender"&gt;官档&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;Logger&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;Loggers&lt;/code&gt;标签中可以指定多个&lt;code&gt;Logger&lt;/code&gt;记录器。其中&lt;code&gt;Root&lt;/code&gt;标签必须存在（在 Properties 文件中，使用&lt;code&gt;rootLogger&lt;/code&gt;），作为根记录器，匹配所有的 log 行为。其他的&lt;code&gt;Logger&lt;/code&gt;标签可以通过&lt;code&gt;name&lt;/code&gt;属性指定匹配的&lt;code&gt;Logger&lt;/code&gt;名称，也就是&lt;code&gt;LogManager.getLogger(name)&lt;/code&gt;中传入的名称，默认为类名。&lt;/p&gt;
&lt;p&gt;日志打印行为会匹配所有匹配的&lt;code&gt;Logger&lt;/code&gt;标签，如果希望匹配后截断，可以指定&lt;code&gt;additivity&lt;/code&gt;属性为false。&lt;/p&gt;
&lt;p&gt;一个样例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;Configuration&lt;/span&gt; &lt;span class="na"&gt;status=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;INFO&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;Properties&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;Property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;filename&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;target/test.log&lt;span class="nt"&gt;&amp;lt;/Property&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/Properties&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;Appenders&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;Console&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Console&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;PatternLayout&lt;/span&gt; &lt;span class="na"&gt;pattern=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

        &lt;span class="nt"&gt;&amp;lt;/Console&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/Appenders&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;Loggers&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;Root&lt;/span&gt; &lt;span class="na"&gt;level=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;trace&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;AppenderRef&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Console&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/Root&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;Logger&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;com.trendcom.tour.A&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;level=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;trace&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;AppenderRef&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Console&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/Logger&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;Logger&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;com.trendcom.tour&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;level=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;trace&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;additivity=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;false&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;AppenderRef&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Console&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/Logger&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/Loggers&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/Configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Log4j 1.x &amp;amp; 2.x&lt;/h2&gt;
&lt;p&gt;具体介绍请看 &lt;a href="http://logging.apache.org/log4j/2.x/manual/index.html"&gt;Introduction&lt;/a&gt;，我浏览了一下系统依赖库，发现已经存在 Log4j 1.x，并且在根目录中也有 log4j.property。为了绕过系统级的迁移问题，如果不能并存，最好暂时使用 1.x。&lt;/p&gt;</summary><category term="Java"></category><category term="log4j"></category></entry><entry><title>Android 学习日记 Day 1</title><link href="http://pollow.github.io/android-xue-xi-ri-ji-day-1.html" rel="alternate"></link><updated>2016-01-14T00:00:00+08:00</updated><author><name>XING Chang</name></author><id>tag:pollow.github.io,2016-01-14:android-xue-xi-ri-ji-day-1.html</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;人生不如意，事十常八九。最嫌弃 Java 的我正在维护一套 legacy 的 Java Web 系统，还在为了帮人做论文而学习 Android 开发。&lt;/p&gt;
&lt;p&gt;这种大型工具链最难学，知识细节十分琐碎，而且主要集中在工具的使用和针对性框架知识的积累，主要靠背。而且环境搭建更是难中之难……&lt;/p&gt;
&lt;p&gt;把学习中的一些知识点记录积累一下，方便复习吧。&lt;/p&gt;
&lt;h2&gt;学习资料&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://developer.android.com/develop/index.html"&gt;Develop Apps&lt;/a&gt;
&lt;a href="http://www.amazon.cn/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-Android-%E9%83%AD%E9%9C%96/dp/B00LVHTI9U/ref=pd_bxgy_14_img_2?ie=UTF8&amp;amp;refRID=0G5C7P8T3HFKK0APVNV5"&gt;《第一行代码-Android》&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;环境配置&lt;/h2&gt;
&lt;p&gt;今天赶巧家里网不稳定，下载东西断断续续，花了一上午才把环境搭建起来。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载&amp;amp;安装 Android Studio，推荐使用最新稳定版。&lt;/li&gt;
&lt;li&gt;OS X 需要单独下载 SDK Tools，放到指定目录。&lt;/li&gt;
&lt;li&gt;随便建个工程，进入 AS 后打开 SDK Manager，下载如下项目：&lt;ol&gt;
&lt;li&gt;Android SDK Tools&lt;/li&gt;
&lt;li&gt;Android SDK Platform-tools&lt;/li&gt;
&lt;li&gt;Android SDK Build-tools&lt;/li&gt;
&lt;li&gt;SDK Platform&lt;/li&gt;
&lt;li&gt;ARM EABI v7a System Image&lt;/li&gt;
&lt;li&gt;Intel x86 Atom 64 System Image&lt;/li&gt;
&lt;li&gt;Sources for Android SDK&lt;/li&gt;
&lt;li&gt;Android Support Repo&lt;/li&gt;
&lt;li&gt;Android Support Lib&lt;/li&gt;
&lt;li&gt;Intel x86 Emulator Accelerator (HAXM Installer)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;在 SDK Manager 的 Settings 中可以设置国内源&lt;a href="www.androiddevtools.cn"&gt;AndroidDevTools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在 AS 中的 System Settings 中也可以设置代理，可以将本地的shadowsocks配置上去。&lt;/li&gt;
&lt;li&gt;打开 AVD Manager，安装 HAXM&lt;/li&gt;
&lt;li&gt;新建 Emulator，推荐使用x86镜像，据说速度快一些，有兼容性问题时再使用ARM版。&lt;/li&gt;
&lt;li&gt;编译运行Hello World。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一天配置环境，感觉还有很多疑问没有解决，比如每个 Android 版本都有可用的 SDK ，是只需要安装最新的，还是所有要兼容的目标版本都需要呢？SDK 那里有很多项目都是每个 Android 版本都有一个，官网推荐下载最新的，那么如果需要开发针对低版本的 app，需不需要低版本的 SDK Tools 呢？编译的时候发生了些什么，这个 Gradle 构建的流程是什么？这么多的资源文件如何组织起来的？&lt;/p&gt;
&lt;p&gt;希望进一步的学习可以解决这些疑问。&lt;/p&gt;</summary><category term="memo"></category><category term="env"></category><category term="android"></category></entry><entry><title>[Brief Note] Git rebase 小结</title><link href="http://pollow.github.io/brief-note-git-rebase-xiao-jie.html" rel="alternate"></link><updated>2016-01-12T01:26:51+08:00</updated><author><name>XING Chang</name></author><id>tag:pollow.github.io,2016-01-12:brief-note-git-rebase-xiao-jie.html</id><summary type="html">&lt;h2&gt;Githug&lt;/h2&gt;
&lt;p&gt;前几天再 Timeline 上看到有人推荐了一款叫做 Githug 的小游戏，通过解决任务学习 Git 的操作使用。由于感觉自己对于 Git 的使用一直停留在比较初级的阶段，有比较多的知识盲点，所以决定下载下来玩一玩，顺便把&lt;a href=""&gt;题解&lt;/a&gt;和学习笔记分别记录一下。&lt;/p&gt;
&lt;h2&gt;Pro Git&lt;/h2&gt;
&lt;p&gt;开始的内容比较简单也比较顺利，在 level 28 第一次遇到了问题——涉及到了rebase。这个功能虽然之前也有使用，但是对于概念一直有所困惑，正巧同时再 Startup News 上看到&lt;a href="http://git-scm.com/book/zh"&gt;《Pro Git 2ed》中文版&lt;/a&gt;翻译校对完成，就顺手上去看了一下有关章节，在这里简略记录一些内容。&lt;/p&gt;
&lt;h2&gt;rebase&lt;/h2&gt;
&lt;p&gt;推荐阅读：&lt;a href="http://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA"&gt;3.6 Git 分支 - 变基&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Git 的分支合并有 &lt;code&gt;merge&lt;/code&gt; 和 &lt;code&gt;rebase&lt;/code&gt; 两种操作。区别在于 merge 只简单的完成代码合并，而 rebase 则是提取两个不同分支（源分支与目标分支）的公共祖先作为基底，生成源分支的 patch 再应用到目标分支上，同时清理冗余的提交。&lt;/p&gt;
&lt;p&gt;概念其实比较简单，只要注意应用到合适的场合，也就是清理冗余提交信息时，就比较合适，原文讲解的十分清晰。&lt;/p&gt;
&lt;p&gt;有一点要注意的是，rebase 操作应当&lt;strong&gt;仅应用到本地仓库的提交记录整理&lt;/strong&gt;上，如果 rebase 了远程的提交和分支，则会导致所有参与开发的人得分支依赖变得一片混乱，&lt;strong&gt;『人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你』。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然也有解决方案，当公共仓库的提交已经发生 rebase，也就是说本地分支依赖的提交可能已经被删除的时候，不要直接 &lt;code&gt;git pull&lt;/code&gt;，而是取到本地后执行 rebase 操作，或者直接：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git pull --rebase
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Git 的操作规范推荐每次&lt;code&gt;git fetch&lt;/code&gt;下来以后视情况决定 merge 和 pull 操作，而我实际上习惯每次直接执行&lt;code&gt;git pull&lt;/code&gt;操作。对于这种情况，有一个全局设定可以将&lt;code&gt;git pull&lt;/code&gt;操作默认执行&lt;code&gt;--rebase&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git config --global pull.rebase true
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;merge or rebase&lt;/h2&gt;
&lt;p&gt;今天还在阮一峰的博客上看到了&lt;a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html"&gt;《Commit message 和 Change log 编写指南》&lt;/a&gt;这篇文章，介绍了 commit 信息的编写规范，和利用 commit 信息直接生成 Change log 的技术和相应地工具。个人认为这种规范的制定十分合理，在大型系统维护时，追溯版本管理记录是检阅 bug 的最佳方式，而清晰明了富有意义的提交信息无疑提供了更丰富的线索。&lt;/p&gt;
&lt;p&gt;但是本地分支开发时，通常要频繁的进行提交，确保工作记录可以追溯，方便测试和调试，产生的提交记录往往十分散乱并且意义不明，在开发时这些提交有积极地意义，但却是后期的维护时沉重的负担。所以我个人倾向于在分支合并时进行 rebase 操作，时提交信息简单易读又清晰明了。&lt;/p&gt;
&lt;h2&gt;Solution for level 28&lt;/h2&gt;
&lt;p&gt;Githug level 28 的任务提示如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Your local master branch has diverged from the remote origin/master branch. Rebase your commit onto origin/master and push it to remote.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是最不应该发生的 &lt;strong&gt;rebase 了公共仓库提交&lt;/strong&gt;的情况，按照前文所述的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git pull --rebase
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;拉取数据，之后直接&lt;code&gt;git push&lt;/code&gt;即可。&lt;/p&gt;</summary><category term="brief"></category><category term="git"></category></entry><entry><title>Hello World</title><link href="http://pollow.github.io/hello-world.html" rel="alternate"></link><updated>2016-01-11T01:28:23+08:00</updated><author><name>XING Chang</name></author><id>tag:pollow.github.io,2016-01-11:hello-world.html</id><summary type="html">&lt;h2&gt;Hello World&lt;/h2&gt;
&lt;p&gt;三年来第三次开通Blog，Wordpress 也配置过了，自己的博客系统也写过了，自己的静态博客引擎也写过了，然并卵，折腾的时间不少，文章才只写了三四篇。&lt;/p&gt;
&lt;p&gt;简简单单最好了，这次试用一下 Pelican + Github.IO，不要在乎形式，希望可以坚持写下去，记录一下自己的学习历程吧。&lt;/p&gt;
&lt;p&gt;Hello World, AGAIN.&lt;/p&gt;</summary></entry></feed>